@author by seanxh

协议
Protocol
--------

memcached的客户端通过TCP连接与服务器通信(同时也提供UDP接口，详情参见下面的“UDP协议”章节。)。
memcached服务器运行时监听指定（可配置）的端口；客户端连接该端口，并且发送命令到服务器，
读取返回值，最终关闭连接。
Clients of memcached communicate with server through TCP connections.
(A UDP interface is also available; details are below under "UDP
protocol.") A given running memcached server listens on some
(configurable) port; clients connect to that port, send commands to
the server, read responses, and eventually close the connection.

关闭会话不需要发送任何命令。客户端可以在随时关闭连接。注意，虽然memcached的设计可以非常高效的
处理大量（几百，有需要时也可以上千）连接，但我们还是建议客户端缓存他们的连接，而不是每次读写数据
时重新打开它。缓存连接可以节省建立TCP连接的开销（相比之下，服务器端创建一个新连接的开销可以忽略不讲）。
There is no need to send any command to end the session. A client may
just close the connection at any moment it no longer needs it. Note,
however, that clients are encouraged to cache their connections rather
than reopen them every time they need to store or retrieve data.  This
is because memcached is especially designed to work very efficiently
with a very large number (many hundreds, more than a thousand if
necessary) of open connections. Caching connections will eliminate the
overhead associated with establishing a TCP connection (the overhead
of preparing for a new connection on the server side is insignificant
compared to this).

在memcache协议中有两种数据：文本行和非结构化数据。文本行用于客户端发送命令和读取服务端返回值。
非结构化数据用于用于客户端存取数据。服务器会以字节流的形式原样返回它接收到的非结构化数据。
服务器不关心字节序，它也无法探测字节序。非结构数据可以是任意字符；同时，读取数据时，客户端或服务器可以
在前次返回的文本行中确切的知道接下来的数据块的长度。
There are two kinds of data sent in the memcache protocol: text lines
and unstructured data.  Text lines are used for commands from clients
and responses from servers. Unstructured data is sent when a client
wants to store or retrieve data. The server will transmit back
unstructured data in exactly the same way it received it, as a byte
stream. The server doesn't care about byte order issues in
unstructured data and isn't aware of them. There are no limitations on
characters that may appear in unstructured data; however, the reader
of such data (either a client or a server) will always know, from a
preceding text line, the exact length of the data block being
transmitted.

文本行总是以\r\n结束。非结构化数据也是以\r\n结构，尽管\r,\n和其它的8比特字符可以出现在非结构化数据里。
因此，当一个客户端从服务器接收数据时，它必须使用数据块返回的长度来决定数据块是否终止，并不是依据数据块
是否以\r\n结尾。
Text lines are always terminated by \r\n. Unstructured data is _also_
terminated by \r\n, even though \r, \n or any other 8-bit characters
may also appear inside the data. Therefore, when a client retrieves
data from a server, it must use the length of the data block (which it
will be provided with) to determine where the data block ends, and not
the fact that \r\n follows the end of the data block, even though it
does.

Key
Keys
----

memcached使用key来区分存储不同的数据。key是一个文本串，由客户端定义的读取一条数据的唯一标识。
现在,key的长度限制是250个字符（虽然正常情况下客户端不需要如此长的key)；key中不能包含控制符或空白字符。
Data stored by memcached is identified with the help of a key. A key
is a text string which should uniquely identify the data for clients
that are interested in storing and retrieving it.  Currently the
length limit of a key is set at 250 characters (of course, normally
clients wouldn't need to use such long keys); the key must not include
control characters or whitespace.

命令
Commands
--------

有三种命令。
There are three types of commands.

存储命令（有6个："set","add","replace","append","prepend","cas")请求服务器以某个key作为标识
存储数据。客户端发送一条命令，紧跟一个数据块；完成以后，客户端希望接收到一行代表成功或失败的返回值。
Storage commands (there are six: "set", "add", "replace", "append"
"prepend" and "cas") ask the server to store some data identified by a
key. The client sends a command line, and then a data block; after
that the client expects one line of response, which will indicate
success or failure.

读取命令（有2个:"get","gets"）以一组key值（一个或多个）请求服务器返回相应的数据。客户端发送一条包含key
的命令；然后服务器逐一去查找他们，并以一个key对应一个数据块的格式，一行行的返回；最终以"END"结尾。
Retrieval commands (there are two: "get" and "gets") ask the server to
retrieve data corresponding to a set of keys (one or more keys in one
request). The client sends a command line, which includes all the
requested keys; after that for each item the server finds it sends to
the client one response line with information about the item, and one
data block with the item's data; this continues until the server
finished with the "END" response line.

其它命令不涉及到非结构化数据。它们都是发送一条命令，然后返回一行数据，或以"END"结尾的几行数据。
All other commands don't involve unstructured data. In all of them,
the client sends one command line, and expects (depending on the
command) either one line of response, or several lines of response
ending with "END" on the last line.

一个命令以命令的名称开始，其后是以空格分隔的参数。命令全部是小写的，且严格区分大小写。
A command line always starts with the name of the command, followed by
parameters (if any) delimited by whitespace. Command names are
lower-case and are case-sensitive.

过期时间
Expiration times
----------------

一些命令会涉及到客户端向服务器发送过期时间（相对于数据项或请求操作）。在这种情况下，其值可以是
Unix时间戳（从1970年1月1日开始所经过的秒数，以32位存储），或者从当前时间算起的秒数。
在后者中秒数不可以超过（60*60*24*30，30天）；如果客户端发送一个比此数值大的数，服务器会把它
当作一个Unix时间戳而不是当前时间的偏移量。
Some commands involve a client sending some kind of expiration time
(relative to an item or to an operation requested by the client) to
the server. In all such cases, the actual value sent may either be
Unix time (number of seconds since January 1, 1970, as a 32-bit
value), or a number of seconds starting from current time. In the
latter case, this number of seconds may not exceed 60*60*24*30 (number
of seconds in 30 days); if the number sent by a client is larger than
that, the server will consider it to be real Unix time value rather
than an offset from current time.


错误信息
Error strings
-------------

客户端发送的每一个命令都有可能返回错误信息。错误有三种形式：
Each command sent by a client may be answered with an error string
from the server. These error strings come in three types:

- "ERROR\r\n"

  说明客户端发送了一个不存在的命令。
  means the client sent a nonexistent command name.

- "CLIENT_ERROR <error>\r\n"

  说明客户端输入的有些错误，比如，输入没有遵守协议。<error>是关于错误的说明。
  means some sort of client error in the input line, i.e. the input
  doesn't conform to the protocol in some way. <error> is a
  human-readable error string.

- "SERVER_ERROR <error>\r\n"

  说明服务端的某些错误导致服务器不处理这个命令。<error>是关于错误的说明。在某些错误时，会导致
  服务器不能继续向客户端提供服务（并不经常发生），服务有可能会在向客户发送完错误信息后主动关闭同
  客户端的连结。这是仅有的服务器端会关闭与客户端连接的场景。
  means some sort of server error prevents the server from carrying
  out the command. <error> is a human-readable error string. In cases
  of severe server errors, which make it impossible to continue
  serving the client (this shouldn't normally happen), the server will
  close the connection after sending the error line. This is the only
  case in which the server closes a connection to a client.

在以下每个命令的描述中，这些错误错误不会在单独提及，但是客户端必须允许兼容这些错误返回。
In the descriptions of individual commands below, these error lines
are not again specifically mentioned, but clients must allow for their
possibility.

存储命令
Storage commands
----------------

首先，客户端发一个类似于这样的命令：
First, the client sends a command line which looks like this:

<命令名> <key> <标识> <过期时间> <字节> [noreply]\r\n
cas <key> <标识> <过期时间> <字节> [noreply]\r\n

<command name> <key> <flags> <exptime> <bytes> [noreply]\r\n
cas <key> <flags> <exptime> <bytes> <cas unique> [noreply]\r\n

- <命令名> 指"set","add","replace","append"或"prepend"
- <command name> is "set", "add", "replace", "append" or "prepend"

  set ：存储此数据
  "set" means "store this data".

  add ：仅当服务器没有此key的值时才存储新数据
  "add" means "store this data, but only if the server *doesn't* already
  hold data for this key".

  replace : 仅当服务器已经有key的值时才用新值替换
  "replace" means "store this data, but only if the server *does*
  already hold data for this key".


  append : 将此数据追加到一个已经存在的key的数据之后
  "append" means "add this data to an existing key after existing data".

  prepend : 交此数据添加到一个已经存在的key的数据之前
  "prepend" means "add this data to an existing key before existing data".

  append和prepend命令不接收<标识>和<过期时间>参数。他们只更新数据部分，
  忽略<标识>和<过期时间>设置。
  The append and prepend commands do not accept flags or exptime.
  They update existing data portions, and ignore new flag and exptime
  settings.

  "cas"是一个检查并设置的操作，意为“只有当此数据自从我上次获取时至今没有被更新过，
  才存储此新数据”
  "cas" is a check and set operation which means "store this data but
  only if no one else has updated since I last fetched it."

- <key> 表示所存储数据块的键值
- <key> is the key under which the client asks to store the data

- <flag> 表示一个任意的16位无符号的整数(10进制书写)。此标识会与数据块一同存储在服务
器上，并当数据被读取时会一同返回。客户端可以用它来当作一个比特位存储一些特殊数据。这个字段
对服务器是不透明的。注意，在memcached 1.2.1及更高的版本中，flag可能是32位而不是16位，
所以如果想要兼容旧版本，你还是需要限制flag为16位。
- <flags> is an arbitrary 16-bit unsigned integer (written out in
  decimal) that the server stores along with the data and sends back
  when the item is retrieved. Clients may use this as a bit field to
  store data-specific information; this field is opaque to the server.
  Note that in memcached 1.2.1 and higher, flags may be 32-bits, instead
  of 16, but you might want to restrict yourself to 16 bits for
  compatibility with older versions.

- <exptime> 表示过期时间。如果是0，此数据永不过期（虽然有可能被删除或其它数据替换）。
如果是一个非0的数据（可以是一个Unix时间戳或相对于当前时间的秒数偏移量），服务端将保证
过期后客户端将不能再读取到此数据（取决于服务器时间）。
- <exptime> is expiration time. If it's 0, the item never expires
  (although it may be deleted from the cache to make place for other
  items). If it's non-zero (either Unix time or offset in seconds from
  current time), it is guaranteed that clients will not be able to
  retrieve this item after the expiration time arrives (measured by
  server time).

- <bytes> 表示以字节为单位的数据块的大小，不包含\r\n。<bytes>可以为0（即当数据块为空时）。
- <bytes> is the number of bytes in the data block to follow, *not*
  including the delimiting \r\n. <bytes> may be zero (in which case
  it's followed by an empty data block).

- <cas unique> 表示一个现有数据的唯一的64位string/integer。当客户端应该发出"cas"更新时，
应当使用从"gets"命令中返回的此值。
- <cas unique> is a unique 64-bit value of an existing entry.
  Clients should use the value returned from the "gets" command
  when issuing "cas" updates.

- “noreply" 是一个可选参数。用于指明不需要服务发送任何返回值。注意：如果请求命令行异常，
服务端有可能不能正常解析"noreply"。在这种情况时，服务端就有可能向客户端发送错误信息，
随之客户端有可能会被打断。因为客户端应该只传输有效的请求。
- "noreply" optional parameter instructs the server to not send the
  reply.  NOTE: if the request line is malformed, the server can't
  parse "noreply" option reliably.  In this case it may send the error
  to the client, and not reading it on the client side will break
  things.  Client should construct only valid requests.

这一行结束后，客户端发送数据块：
After this line, the client sends the data block:

<data block>\r\n

######################################
- <data block> 是上一行中<bytes>设置长度的任意8字节分块长度。
- <data block> is a chunk of arbitrary 8-bit data of length <bytes>
from the previous line.
#####################################

在发送这一行命令后，客户端会阻塞并等待返回，返回结果可能是：
After sending the command line and the data blockm the client awaits
the reply, which may be:

- "STORED\r\n", 表明成功。
- "STORED\r\n", to indicate success.

- "NOT_STORED\r\n" 表明数据没有保存成功，但并不是因为错误。一般是因为"add"或"replace"的
条件不符。
- "NOT_STORED\r\n" to indicate the data was not stored, but not
because of an error. This normally means that the
condition for an "add" or a "replace" command wasn't met.

- "EXISTS\r\n" 表明你要存储的数据在上次使用cas命令获取之后，被更改过了。
- "EXISTS\r\n" to indicate that the item you are trying to store with
a "cas" command has been modified since you last fetched it.

- "NOT_FOUND\r\n" 表明你要使用"cas"命令存储的数据不存在。
- "NOT_FOUND\r\n" to indicate that the item you are trying to store
with a "cas" command did not exist.


读取命令：
Retrieval command:
------------------

读取命令"get"和"gets"格式如下：
The retrieval commands "get" and "gets" operates like this:

get <key>*\r\n
gets <key>*\r\n

- <key>* 表示一个或多个用空白字符分隔的key。
- <key>* means one or more key strings separated by whitespace.

命令发送后，客户端可能得到0个或多个数据项，每个数据项的格式都是一行文本紧接一个数据块的格式。
当所有数据被发送后，服务端会发送一行
After this command, the client expects zero or more items, each of
which is received as a text line followed by a data block. After all
the items have been transmitted, the server sends the string

"END\r\n"

来表明这一个返回的终止。
to indicate the end of response.

服务端返回的每一行数据格式如下：
Each item sent by the server looks like this:

VALUE <key> <flags> <bytes> [<cas unique>]\r\n
<data block>\r\n

- <key> 是数据的键值
- <key> is the key for the item being sent

- <flags> 是存储数据时所设置的flags
- <flags> is the flags value set by the storage command

- <bytes> 是数据块的长度，不包括边界符\r\n
- <bytes> is the length of the data block to follow, *not* including
  its delimiting \r\n

- <cas unique> 是一个64位的整型数字，唯一标识了这个数据
- <cas unique> is a unique 64-bit integer that uniquely identifies
  this specific item.

- <data block> 是实际的数据
- <data block> is the data for this item.

如果某些key出现在了请求参数里，但服务端并未返回该key相关的数据，则表明服务端没有保存这些Key
(有可能是因为从来没有存储过这个key，或为了给其它数据腾出存储空间被删掉了，或过期，或被客户端
有意的删掉了)
If some of the keys appearing in a retrieval request are not sent back
by the server in the item list this means that the server does not
hold items with such keys (because they were never stored, or stored
but deleted to make space for more items, or expired, or explicitly
deleted by a client).


删除
Deletion
--------

"delete"命令用于明确的删除指定数据项：
The command "delete" allows for explicit deletion of items:

delete <key> [noreply]\r\n

- <key> 是客户端希望服务端删除的key
- <key> is the key of the item the client wishes the server to delete

- "noreply" 是一个可选参数。用于指明服务器不需应答。参考“存储命令”一节的忽略异常请求。
- "noreply" optional parameter instructs the server to not send the
reply.  See the note in Storage commands regarding malformed
requests.

这个命令的返回值有下面几种：
The response line to this command can be one of:

- "DELETED\r\n" 表明操作成功
- "DELETED\r\n" to indicate success

- "NOT_FOUND\r\n" 表明这个key没有在服务端找到
- "NOT_FOUND\r\n" to indicate that the item with this key was not
found.

想要立即清除所有数据请参考下面的"flush_all"命令。
See the "flush_all" command below for immediate invalidation
of all existing items.


递增/递减
-------------------

"incr"和"decr"命令用于就地增长或减少某些数据。这些数据项的数据以64位无符号的10进制整数来表示。
如果这个数据不符合这个表示，incr/decr命令会返回错误(memcached<=1.2.6把这种伪数据当作0处理，引起了混淆)。
而且，数据必须是已经存在的，incr/decr不会把不存在的值当作0处理，相反，它们会失败。
Commands "incr" and "decr" are used to change data for some item
in-place, incrementing or decrementing it. The data for the item is
treated as decimal representation of a 64-bit unsigned integer.  If
the current data value does not conform to such a representation, the
incr/decr commands return an error (memcached <= 1.2.6 treated the
bogus value as if it were 0, leading to confusion). Also, the item
must already exist for incr/decr to work; these commands won't pretend
that a non-existent key exists with value 0; instead, they will fail.

客户端发送命令如下：
The client sends the command line:

incr <key> <value> [noreply]\r\n

或
or

decr <key> <value> [noreply]\r\n

- <key> 表示客户端想要更新的数据的key
- <key> is the key of the item the client wishes to change

- <value> 表示客户端想要服务端对数据增加/减少的值。它是一个10进制表示的64位无符号整数。
- <value> is the amount by which the client wants to increase/decrease
the item. It is a decimal representation of a 64-bit unsigned integer.

- "noreply" 是一个可选参数。表明服务端不需要发送任何返回值。参考“存储命令”一节的忽略异常请求。
- "noreply" optional parameter instructs the server to not send the
reply.  See the note in Storage commands regarding malformed
requests.

返回可能有以下几种情况：
The response will be one of:

- "NOT_FOUND\r\n" 表示数据未找到
- "NOT_FOUND\r\n" to indicate the item with this value was not found

- <value>\r\n 表示当增加/减少操作执行后，数据项新的<value>值。
- <value>\r\n , where <value> is the new value of the item's data,
after the increment/decrement operation was carried out.

注意要捕获"decr"的下限：如果一个客户端试图对一个小于0的值运行"decr"命令，那么新的值会是0。
"incr"命令的上限则要依赖于64位整数的表示。
Note that underflow in the "decr" command is caught: if a client tries
to decrease the value below 0, the new value will be 0.  Overflow in
the "incr" command will wrap around the 64 bit mark.

###################
注意递减数据有可能会使数据的长度变化，所以服务端不保证递减返回值的长度。数据后面有可能会有
空格补齐，但这是纯粹是一种展示上的优化，你不应该依赖于它。
Note also that decrementing a number such that it loses length isn't
guaranteed to decrement its returned length.  The number MAY be
space-padded at the end, but this is purely an implementation
optimization, so you also shouldn't rely on that.
####################

Touch
-----

"touch"命令用于在不获取已存在的数据的情况下，更新这个数据项的过期时间。
The "touch" command is used to update the expiration time of an existing item
without fetching it.

touch <key> <exptime> [noreply]\r\n

- <key> 表示客户端希望服务端删除的数据项的key
- <key> is the key of the item the client wishes the server to delete

- <exptime> 表示过期时间。工作原理同更新命令(set/add等)相同。该命令会替换当前的过期时间。
如果一个数据项将会在10秒后过期，但被touch命令指定过期时间为20，那么这个数据项会在20秒后才
过期。
- <exptime> is expiration time. Works the same as with the update commands
(set/add/etc). This replaces the existing expiration time. If an existing
item were to expire in 10 seconds, but then was touched with an
expiration time of "20", the item would then expire in 20 seconds.

- "noreply" 是一个可靠参数。表示服务端不发送任何响应值。参考“存储命令”一节的忽略异常请求。
- "noreply" optional parameter instructs the server to not send the
reply.  See the note in Storage commands regarding malformed
requests.

命令的返回值可能是以下几种：
The response line to this command can be one of:

- "TOUCHED\r\n" 表示成功
- "TOUCHED\r\n" to indicate success

- "NOT_FOUND\r\n" 表示这个数据项的key没有找到
- "NOT_FOUND\r\n" to indicate that the item with this key was not
found.

Slab重分配
Slabs Reassign
--------------

注意：这个命令在编写本文档时还处于更改中。
NOTE: This command is subject to change as of this writing.

Slab重分配命令用于当对一个达到上限的正在运行的实例进行内存重分配。使用场景是想要使自服务启动
以下自动分配的内存布局发生变化。
The slabs reassign command is used to redistribute memory once a running
instance has hit its limit. It might be desireable to have memory laid out
differently than was automatically assigned after the server started.

slabs reassign <source class> <dest class>\r\n

- <source class> 表示想要”偷“的那个slab class的ID
- <source class> is an id number for the slab class to steal a page from

如果source class为-1，表示”任意一个可用的slab class"
A source class id of -1 means "pick from any valid class"

- <dest class> 表示slab class要移动的目的ID
- <dest class> is an id number for the slab class to move a page to

返回值可能有以下几种情况：
The response line could be one of:

- "OK" 表示这一页已经按指定的参数移动好了
- "OK" to indicate the page has been scheduled to move

- "BUSY [message]" 表示这一页正在被处理，稍后重试
- "BUSY [message]" to indicate a page is already being processed, try again
later.

- "BADCLASS [message]" 表示指定了一个不合法的slab class ID
- "BADCLASS [message]" a bad class id was specified

- "NOSPARE [message]" 内存管理器没有多余的内存了
- "NOSPARE [message]" source class has no spare pages

- "NOTFULL [message]" 新内存页要移动的目标内存块必须是“满”的
- "NOTFULL [message]" dest class must be full to move new pages to it

- "UNSAFE [message]" 内存管理器当前不能正常的移动内存块
- "UNSAFE [message]" source class cannot move a page right now

- "SAME [message]" 源/目标内存块必须是不同的id。
- "SAME [message]" must specify different source/dest ids.

Slab自移动
Slabs Automove
--------------

NOTE: 这个命令在编写本文档时还处于更改中。
NOTE: This command is subject to change as of this writing.

slab自移动命令是用来启动一个后台线程来自动判断何时多个slab class的内存之间需要移动。
它的实现和参数有可能在不同的版本中有所不同。具体请参考wiki/邮件列表。
The slabs automove command enables a background thread which decides on its
own when to move memory between slab classes. Its implementation and options
will likely be in flux for several versions. See the wiki/mailing list for
more details.

自移动线程可以使用此命令打开或关闭。
The automover can be enabled or disabled at runtime with this command.

slabs automove <0|1>

- 0|1|2 表示打开或关闭自移动线程
- 0|1|2 is the indicator on whether to enable the slabs automover or not.

返回值总是"OK\r\n"
The response should always be "OK\r\n"

- <0> 表示将此线程设置为备用
- <0> means to set the thread on standby

- <1> 表示运行内置的缓慢算法来移动内存块
- <1> means to run the builtin slow algorithm to choose pages to move

- <2> 是一个更积进的模式，每次有数据项剔除时它都会被触发。不建议长时间运行此模式，
除非对你的访问模式已经非常了解了。
- <2> is a highly aggressive mode which causes pages to be moved every time
there is an eviction. It is not recommended to run for very long in this
mode unless your access patterns are very well understood.

LRU爬虫
LRU_Crawler
-----------

注意：这个命令(以及相关命令)在编写本文档时还处于更改中。
NOTE: This command (and related commands) are subject to change as of this
writing.

LRU爬虫是一个可选的后台线程，它会沿被请求的slab class尾向头开始爬行，并主动释放过期的数据项。
当你的数据项的TTL长、短不一，却不经常被访问时，这个命令会有所帮助。这个选项如果使用不当，
可能会造成增加CPU使用率增长的隐患。
The LRU Crawler is an optional background thread which will walk from the tail
toward the head of requested slab classes, actively freeing memory for expired
items. This is useful if you have a mix of items with both long and short
TTL's, but aren't accessed very often. This system is not required for normal
usage, and can add small amounts of latency and increase CPU usage.

lru_crawler <enable|disable>

- 开启或关闭LUR爬虫后台线程
- Enable or disable the LRU Crawler background thread.

这行命令有如下几种返回情况：
The response line could be one of:

- "OK" 表明爬虫已经开启或停止了。
- "OK" to indicate the crawler has been started or stopped.

- "ERROR [message]" 开启或停止爬虫时出错了
- "ERROR [message]" something went wrong while enabling or disabling.

lru_crawler sleep <microseconds>

- 毫秒数，检查数据项是否过期的周期。数字越小显然会对影响系统造成更多影响。
"0"不会sleep,上限为"1000000"(1秒)。
- The number of microseconds to sleep inbetween each item checked for
expiration. Smaller numbers will obviously impact the system more.
A value of "0" disables the sleep, "1000000" (one second) is the max.

命令的返回值有以下几种情况：
The response line could be one of:

- "OK"

- "CLIENT_ERROR [message]" 表明格式错误或毫秒数出界。
- "CLIENT_ERROR [message]" indicating a format or bounds issue.

lru_crawler tocrawl <32u>

- 每次请求时在一个slab class中所检查的数据项的上限。这个选项避免了当不太可能发现过期元素时，
检查特别大的slab的所有数据项。
- The maximum number of items to inspect in a slab class per run request. This
allows you to avoid scanning all of very large slabs when it is unlikely to
find items to expire.

返回值有以下几种情况：
The response line could be one of:

- "OK"

- "CLIENT_ERROR [message]" 表明格式错误或毫秒数出界。
- "CLIENT_ERROR [message]" indicating a format or bound issue.

lru_crawler crawl <classid,classid,classid|all>

- 参数可以是一个或多个slab class的ID(如：1，3，10)。它会使爬虫从这些指定的slab class的
尾部到头部依次爬行。在爬虫完成上一个请求之前，它不能够被停止或重启。
- Takes a single, or a list of, numeric classids (ie: 1,3,10). This instructs
the crawler to start at the tail of each of these classids and run to the
head. The crawler cannot be stopped or restarted until it completes the
previous request.

"all"是一个特殊的关键词，它表示让爬虫爬行所有slab中的数据项。
The special keyword "all" instructs it to crawl all slabs with items in
them.

返回值有以下几种情况：
The response line could be one of:

- "OK" 表示运行成功。
- "OK" to indicate successful launch.

- "BUSY [message]" 表示爬虫正在处理一个请求
- "BUSY [message]" to indicate the crawler is already processing a request.

- "BADCLASS [message]" 表示指定了一个非法的slab class ID
- "BADCLASS [message]" to indicate an invalid class was specified.

统计
Statistics
----------

"stats"命令用于查询服务的运行情况和其它内部数据。它有两种形式。没有参数的：
The command "stats" is used to query the server about statistics it
maintains and other internal data. It has two forms. Without
arguments:

stats\r\n

它会使服务端输出通用的统计和设置信息，说明在下面。它还有一个有参数的形式：
it causes the server to output general-purpose statistics and
settings, documented below.  In the other form it has some arguments:

stats <args>\r\n

依赖于<args>，服务端会返回不同的内部数据。参数的类型和返回数据格式没有在这个版本的
协议中标注，这样以方便memcache开发者者们去更改它。
Depending on <args>, various internal data is sent by the server. The
kinds of arguments and the data sent are not documented in this version
of the protocol, and are subject to change for the convenience of
memcache developers.


通用统计信息
General-purpose statistics
--------------------------

如果接收到的"stats"命令没有参数，服务端会返回类似于下面的信息：
Upon receiving the "stats" command without arguments, the server sents
a number of lines which look like this:

STAT <name> <value>\r\n

返回信息的在这一行终止
The server terminates this list with the line

END\r\n

在统计信息中的每一行中，<name>是统计信息的名称，<value>是数据值。下面的列表是"stats"
命令返回值的所有名称，以及其值的类型和意义。
In each line of statistics, <name> is the name of this statistic, and
<value> is the data.  The following is the list of all names sent in
response to the "stats" command, together with the type of the value
sent for this name, and the meaning of the value.

在类型这一列中，"32u"代表32位的无符号整数，"64u"代表64位的无符号整数。"32u.32u"代表
被冒号分隔的两个32位无符号数据，可以把它当作浮点型小数。
In the type column below, "32u" means a 32-bit unsigned integer, "64u"
means a 64-bit unsigned integer. '32u.32u' means two 32-bit unsigned
integers separated by a colon (treat this as a floating point number).

|-----------------------+---------+-----------------------------------------------|
| 名称                   | 类型    | 含义                                           |
|-----------------------+---------+-----------------------------------------------|
| pid                   | 32u     | 服务端的进程                                    |
|                       |         | ID Process id of this server process          |
| uptime                | 32u     | 服务端自启动以来经历的秒数                        |
|                       |         | Number of secs since the server started       |
| time                  | 32u     | 服务端当前的UNIX时间戳                           |
|                       |         | current UNIX time according to the server     |
| version               | string  | 服务端的版本                                    |
|                       |         | Version string of this server                 |
| pointer_size          | 32      | 服务器操作系统指定的大小（通常是32或64）           |
|                       |         | Default size of pointers on the host OS       |
|                       |         | (generally 32 or 64)                          |
| rusage_user           | 32u.32u | 处理请求所花费的用户时间的累积值                   |
|                       |         | Accumulated user time for this process        |
|                       |         | （秒:毫秒数）(seconds:microseconds)             |
| rusage_system         | 32u.32u | 处理请求所花费的系统时间的累积值（秒:毫秒数）       |
|                       |         | Accumulated system time for this process      |
|                       |         | (seconds:microseconds)                        |
| curr_items            | 32u     | 当前所存储的数据项的个数                          |
|                       |         | Current number of items stored                |
| total_items           | 32u     | 自服务启动以来所存储的数据项的总个数               |
|                       |         | Total number of items stored since            |
|                       |         | the server started                            |
| bytes                 | 64u     | 所存储数据的总字节数                             |
|                       |         | Current number of bytes used                  |
|                       |         | to store items                                |
| curr_connections      | 32u     | 当前打开的连接个数                               |
|                       |         | Number of open connections                    |
| total_connections     | 32u     | 自服务启动以来打开的连接总数                      |
|                       |         | Total number of connections opened since      |
|                       |         | the server started running                    |
| connection_structures | 32u     | 服务端分配的连接结构的个数                        |
|                       |         | Number of connection structures allocated     |
|                       |         | by the server                                 |
| reserved_fds          | 32u     | 内部所使用的fd个数                              |
|                       |         | Number of misc fds used internally            |
| cmd_get               | 64u     | 读取命令的累积个数                               |
|                       |         | Cumulative number of retrieval reqs           |
| cmd_set               | 64u     | 存储命令的累积个数                               |
|                       |         | Cumulative number of storage reqs             |
| cmd_flush             | 64u     | flush命令的累积个数                             |
|                       |         | Cumulative number of flush reqs               |
| cmd_touch             | 64u     | touch命令的累积个数                             |
|                       |         | Cumulative number of touch reqs               |
| get_hits              | 64u     | 到目前为止被请求且找到的key的个数                  |
|                       |         | Number of keys that have been requested       |
|                       |         | and found present                             |
| get_misses            | 64u     | 到目前为止被请求未找到的key的个数                  |
|                       |         | Number of items that have been requested      |
|                       |         | and not found                                 |
| delete_misses         | 64u     | 删除请求未找到的key的个数                        |
|                       |         | Number of deletions reqs for missing keys     |
| delete_hits           | 64u     | 删除请求删除的key的个数                          |
|                       |         | Number of deletion reqs resulting in          |
|                       |         | an item being removed.                        |
| incr_misses           | 64u     | incr命令未找到的key的个数                        |
|                       |         | Number of incr reqs against missing keys.     |
| incr_hits             | 64u     | incr命令成功执行的次数                           |
|                       |         | Number of successful incr reqs.               |
| decr_misses           | 64u     | decr命令未找到key的个数                          |
|                       |         | Number of decr reqs against missing keys.     |
| decr_hits             | 64u     | decr命令成功的次数                               |
|                       |         | Number of successful decr reqs.               |
| cas_misses            | 64u     | cas命令未找到key的次数                           |
|                       |         | Number of CAS reqs against missing keys.      |
| cas_hits              | 64u     | cas命令成功的次数                               |
|                       |         | Number of successful CAS reqs.                |
| cas_badval            | 64u     | cas key找到，但是cas值不符的次数                 |
|                       |         | Number of CAS reqs for which a key was        |
|                       |         | found, but the CAS value did not match.       |
| touch_hits            | 64u     | 被touch命令设置新过期时间的key的个数              |
|                       |         | Numer of keys that have been touched with     |
|                       |         | a new expiration time                         |
| touch_misses          | 64u     | 被touch命令设置但未找到key的个数                  |
|                       |         | Numer of items that have been touched and     |
|                       |         | not found                                     |
| auth_cmds             | 64u     | authentication命令的个数，成功或失败             |
|                       |         | Number of authentication commands             |
|                       |         | handled, success or failure.                  |
| auth_errors           | 64u     | 授权失败的次数                                  |
|                       |         | Number of failed authentications.             |
| evictions             | 64u     | 在缓存中为给新数据项提供空间被移除的数据项个数       |
|                       |         | Number of valid items removed from cache      |
|                       |         | to free memory for new items                  |
| reclaimed             | 64u     | 元素被存储进一个已经过期的元素的内存中的次数         |
|                       |         | Number of times an entry was stored using     |
|                       |         | memory from an expired entry                  |
| bytes_read            | 64u     | 服务端通过网络被读取的数据的总字节数               |
|                       |         | Total number of bytes read by this server     |
|                       |         | from network                                  |
| bytes_written         | 64u     | 服务端通过网络发送的数据的总字节数                 |
|                       |         | Total number of bytes sent by this server     |
|                       |         | to network                                    |
| limit_maxbytes        | 32u     | 服务端被允许使用的存储最大上限的字节数              |
|                       |         | Number of bytes this server is allowed to     |
|                       |         | use for storage.                              |
| threads               | 32u     | 请求处理线程的个数（参照doc/threads.txt)          |
|                       |         | Number of worker threads requested.           |
|                       |         | (see doc/threads.txt)                         |
| conn_yields           | 64u     | 由于触发-R限制导致连接不成功的次数                 |
|                       |         | Number of times any connection yielded to     |
|                       |         | another due to hitting the -R limit.          |
| hash_power_level      | 32u     | 当前哈希表的倍增器大小                           |
|                       |         | Current size multiplier for hash table        |
| hash_bytes            | 64u     | 当前哈希表使用的总字节大小                        |
|                       |         | Bytes currently used by hash tables           |
| hash_is_expanding     | bool    | 表明哈希表当前是否正在增长成新的容量               |
|                       |         | Indicates if the hash table is being          |
|                       |         | grown to a new size                           |
| expired_unfetched     | 64u     | 被LRU过期删除的从未被get/incr/apped等命令访问过    |
|                       |         | 的元素个数                                      |
|                       |         | Items pulled from LRU that were never         |
|                       |         | touched by get/incr/append/etc before         |
|                       |         | expiring                                      |
| evicted_unfetched     | 64u     | 被LRU剔除的从未被get/incr/append等命令访问        |
|                       |         | 过的数据项个数                                  |
|                       |         | Items evicted from LRU that were never        |
|                       |         | touched by get/incr/append/etc.               |
| slab_reassign_running | bool    | slab页是否正在移动                              |
|                       |         | If a slab page is being moved                 |
| slabs_moved           | 64u     | slab页移动的总次数                              |
|                       |         | Total slab pages moved                        |
| crawler_reclaimed     | 64u     | 被LRU爬虫释放的数据项总个数                       |
|                       |         | Total items freed by LRU Crawler              |
| lrutail_reflocked     | 64u     | 主动发现被锁LRU尾部元素的次数                     |
|                       |         | 元素被移动到头部以防止OOM(内存溢出)错误            |
|                       |         | Times LRU tail was found with active ref.     |
|                       |         | Items moved to head to avoid OOM errors.      |
|-----------------------+---------+-----------------------------------------------|

译者注：
如果客户端偶尔获取大量数据项，导致TCP缓存无法装下的时候，服务会阻塞相当长的时间，
slab class可能会导致OOM。在比较老的版本上，memcached会崩溃。在从1.4.20后会
引发OOM错误。
自1.4.21版本后，如果一个被锁住的元素处于LRU的尾部，它会被强制顶回头部
并且lrutail_reflocked计数器加1。如果你比较关心客户端卡住的情况，可以看一下这个计数器。
参考：https://code.google.com/p/memcached/wiki/ReleaseNotes1421

Settings statistics
-------------------
CAVEAT: This section describes statistics which are subject to change in the
future.

The "stats" command with the argument of "settings" returns details of
the settings of the running memcached.  This is primarily made up of
the results of processing commandline options.

Note that these are not guaranteed to return in any specific order and
this list may not be exhaustive.  Otherwise, this returns like any
other stats command.

|-------------------+----------+----------------------------------------------|
| Name              | Type     | Meaning                                      |
|-------------------+----------+----------------------------------------------|
| maxbytes          | size_t   | Maximum number of bytes allows in this cache |
| maxconns          | 32       | Maximum number of clients allowed.           |
| tcpport           | 32       | TCP listen port.                             |
| udpport           | 32       | UDP listen port.                             |
| inter             | string   | Listen interface.                            |
| verbosity         | 32       | 0 = none, 1 = some, 2 = lots                 |
| oldest            | 32u      | Age of the oldest honored object.            |
| evictions         | on/off   | When off, LRU evictions are disabled.        |
| domain_socket     | string   | Path to the domain socket (if any).          |
| umask             | 32 (oct) | umask for the creation of the domain socket. |
| growth_factor     | float    | Chunk size growth factor.                    |
| chunk_size        | 32       | Minimum space allocated for key+value+flags. |
| num_threads       | 32       | Number of threads (including dispatch).      |
| stat_key_prefix   | char     | Stats prefix separator character.            |
| detail_enabled    | bool     | If yes, stats detail is enabled.             |
| reqs_per_event    | 32       | Max num IO ops processed within an event.    |
| cas_enabled       | bool     | When no, CAS is not enabled for this server. |
| tcp_backlog       | 32       | TCP listen backlog.                          |
| auth_enabled_sasl | yes/no   | SASL auth requested and enabled.             |
| item_size_max     | size_t   | maximum item size                            |
| maxconns_fast     | bool     | If fast disconnects are enabled              |
| hashpower_init    | 32       | Starting size multiplier for hash table      |
| slab_reassign     | bool     | Whether slab page reassignment is allowed    |
| slab_automove     | bool     | Whether slab page automover is enabled       |
| hash_algorithm    | char     | Hash table algorithm in use                  |
| lru_crawler       | bool     | Whether the LRU crawler is enabled           |
| lru_crawler_sleep | 32       | Microseconds to sleep between LRU crawls     |
| lru_crawler_tocrawl| 32u     | Max items to crawl per slab per run          |
|-------------------+----------+----------------------------------------------|


Item statistics
---------------
CAVEAT: This section describes statistics which are subject to change in the
future.

The "stats" command with the argument of "items" returns information about
item storage per slab class. The data is returned in the format:

STAT items:<slabclass>:<stat> <value>\r\n

The server terminates this list with the line

END\r\n

The slabclass aligns with class ids used by the "stats slabs" command. Where
"stats slabs" describes size and memory usage, "stats items" shows higher
level information.

The following item values are defined as of writing.

Name                   Meaning
------------------------------
number                 Number of items presently stored in this class. Expired
items are not automatically excluded.
age                    Age of the oldest item in the LRU.
evicted                Number of times an item had to be evicted from the LRU
before it expired.
evicted_nonzero        Number of times an item which had an explicit expire
time set had to be evicted from the LRU before it
expired.
evicted_time           Seconds since the last access for the most recent item
evicted from this class. Use this to judge how
recently active your evicted data is.
outofmemory            Number of times the underlying slab class was unable to
store a new item. This means you are running with -M or
an eviction failed.
tailrepairs            Number of times we self-healed a slab with a refcount
leak. If this counter is increasing a lot, please
report your situation to the developers.
reclaimed              Number of times an entry was stored using memory from
an expired entry.
expired_unfetched      Number of expired items reclaimed from the LRU which
were never touched after being set.
evicted_unfetched      Number of valid items evicted from the LRU which were
never touched after being set.
crawler_reclaimed      Number of items freed by the LRU Crawler.

Note this will only display information about slabs which exist, so an empty
cache will return an empty set.


Item size statistics
--------------------
CAVEAT: This section describes statistics which are subject to change in the
future.

The "stats" command with the argument of "sizes" returns information about the
general size and count of all items stored in the cache.
WARNING: This command WILL lock up your cache! It iterates over *every item*
and examines the size. While the operation is fast, if you have many items
you could prevent memcached from serving requests for several seconds.

The data is returned in the following format:

<size> <count>\r\n

The server terminates this list with the line

END\r\n

'size' is an approximate size of the item, within 32 bytes.
'count' is the amount of items that exist within that 32-byte range.

This is essentially a display of all of your items if there was a slab class
for every 32 bytes. You can use this to determine if adjusting the slab growth
factor would save memory overhead. For example: generating more classes in the
lower range could allow items to fit more snugly into their slab classes, if
most of your items are less than 200 bytes in size.


Slab statistics
---------------
CAVEAT: This section describes statistics which are subject to change in the
future.

The "stats" command with the argument of "slabs" returns information about
each of the slabs created by memcached during runtime. This includes per-slab
information along with some totals. The data is returned in the format:

STAT <slabclass>:<stat> <value>\r\n
STAT <stat> <value>\r\n

The server terminates this list with the line

END\r\n

|-----------------+----------------------------------------------------------|
| Name            | Meaning                                                  |
|-----------------+----------------------------------------------------------|
| chunk_size      | The amount of space each chunk uses. One item will use   |
|                 | one chunk of the appropriate size.                       |
| chunks_per_page | How many chunks exist within one page. A page by         |
|                 | default is less than or equal to one megabyte in size.   |
|                 | Slabs are allocated by page, then broken into chunks.    |
| total_pages     | Total number of pages allocated to the slab class.       |
| total_chunks    | Total number of chunks allocated to the slab class.      |
| get_hits        | Total number of get requests serviced by this class.     |
| cmd_set         | Total number of set requests storing data in this class. |
| delete_hits     | Total number of successful deletes from this class.      |
| incr_hits       | Total number of incrs modifying this class.              |
| decr_hits       | Total number of decrs modifying this class.              |
| cas_hits        | Total number of CAS commands modifying this class.       |
| cas_badval      | Total number of CAS commands that failed to modify a     |
|                 | value due to a bad CAS id.                               |
| touch_hits      | Total number of touches serviced by this class.          |
| used_chunks     | How many chunks have been allocated to items.            |
| free_chunks     | Chunks not yet allocated to items, or freed via delete.  |
| free_chunks_end | Number of free chunks at the end of the last allocated   |
|                 | page.                                                    |
| mem_requested   | Number of bytes requested to be stored in this slab[*].  |
| active_slabs    | Total number of slab classes allocated.                  |
| total_malloced  | Total amount of memory allocated to slab pages.          |
|-----------------+----------------------------------------------------------|

* Items are stored in a slab that is the same size or larger than the
item.  mem_requested shows the size of all items within a
slab. (total_chunks * chunk_size) - mem_requested shows memory
wasted in a slab class.  If you see a lot of waste, consider tuning
the slab factor.


Connection statistics
---------------------
The "stats" command with the argument of "conns" returns information
about currently active connections and about sockets that are listening
for new connections. The data is returned in the format:

STAT <file descriptor>:<stat> <value>\r\n

The server terminates this list with the line

END\r\n

The following "stat" keywords may be present:

|---------------------+------------------------------------------------------|
| Name                | Meaning                                              |
|---------------------+------------------------------------------------------|
| addr                | The address of the remote side. For listening        |
|                     | sockets this is the listen address. Note that some   |
|                     | socket types (such as UNIX-domain) don't have        |
|                     | meaningful remote addresses.                         |
| state               | The current state of the connection. See below.      |
| secs_since_last_cmd | The number of seconds since the most recently        |
|                     | issued command on the connection. This measures      |
|                     | the time since the start of the command, so if       |
|                     | "state" indicates a command is currently executing,  |
|                     | this will be the number of seconds the current       |
|                     | command has been running.                            |
|---------------------+------------------------------------------------------|

The value of the "state" stat may be one of the following:

|----------------+-----------------------------------------------------------|
| Name           | Meaning                                                   |
|----------------+-----------------------------------------------------------|
| conn_closing   | Shutting down the connection.                             |
| conn_listening | Listening for new connections or a new UDP request.       |
| conn_mwrite    | Writing a complex response, e.g., to a "get" command.     |
| conn_new_cmd   | Connection is being prepared to accept a new command.     |
| conn_nread     | Reading extended data, typically for a command such as    |
|                | "set" or "put".                                           |
| conn_parse_cmd | The server has received a command and is in the middle    |
|                | of parsing it or executing it.                            |
| conn_read      | Reading newly-arrived command data.                       |
| conn_swallow   | Discarding excess input, e.g., after an error has         |
|                | occurred.                                                 |
| conn_waiting   | A partial command has been received and the server is     |
|                | waiting for the rest of it to arrive (note the difference |
|                | between this and conn_nread).                             |
| conn_write     | Writing a simple response (anything that doesn't involve  |
|                | sending back multiple lines of response data).            |
|----------------+-----------------------------------------------------------|



Other commands
--------------

"flush_all" is a command with an optional numeric argument. It always
succeeds, and the server sends "OK\r\n" in response (unless "noreply"
is given as the last parameter). Its effect is to invalidate all
existing items immediately (by default) or after the expiration
specified.  After invalidation none of the items will be returned in
response to a retrieval command (unless it's stored again under the
same key *after* flush_all has invalidated the items). flush_all
doesn't actually free all the memory taken up by existing items; that
will happen gradually as new items are stored. The most precise
definition of what flush_all does is the following: it causes all
items whose update time is earlier than the time at which flush_all
was set to be executed to be ignored for retrieval purposes.

The intent of flush_all with a delay, was that in a setting where you
have a pool of memcached servers, and you need to flush all content,
you have the option of not resetting all memcached servers at the
same time (which could e.g. cause a spike in database load with all
clients suddenly needing to recreate content that would otherwise
have been found in the memcached daemon).

The delay option allows you to have them reset in e.g. 10 second
intervals (by passing 0 to the first, 10 to the second, 20 to the
third, etc. etc.).


"version" is a command with no arguments:

version\r\n

In response, the server sends

"VERSION <version>\r\n", where <version> is the version string for the
server.

"verbosity" is a command with a numeric argument. It always succeeds,
and the server sends "OK\r\n" in response (unless "noreply" is given
as the last parameter). Its effect is to set the verbosity level of
the logging output.

"quit" is a command with no arguments:

quit\r\n

Upon receiving this command, the server closes the
connection. However, the client may also simply close the connection
when it no longer needs it, without issuing this command.


UDP protocol
------------

For very large installations where the number of clients is high enough
that the number of TCP connections causes scaling difficulties, there is
also a UDP-based interface. The UDP interface does not provide guaranteed
delivery, so should only be used for operations that aren't required to
succeed; typically it is used for "get" requests where a missing or
incomplete response can simply be treated as a cache miss.

Each UDP datagram contains a simple frame header, followed by data in the
same format as the TCP protocol described above. In the current
implementation, requests must be contained in a single UDP datagram, but
responses may span several datagrams. (The only common requests that would
span multiple datagrams are huge multi-key "get" requests and "set"
requests, both of which are more suitable to TCP transport for reliability
reasons anyway.)

The frame header is 8 bytes long, as follows (all values are 16-bit integers
in network byte order, high byte first):

0-1 Request ID
2-3 Sequence number
4-5 Total number of datagrams in this message
6-7 Reserved for future use; must be 0

The request ID is supplied by the client. Typically it will be a
monotonically increasing value starting from a random seed, but the client
is free to use whatever request IDs it likes. The server's response will
contain the same ID as the incoming request. The client uses the request ID
to differentiate between responses to outstanding requests if there are
several pending from the same server; any datagrams with an unknown request
ID are probably delayed responses to an earlier request and should be
discarded.

The sequence number ranges from 0 to n-1, where n is the total number of
datagrams in the message. The client should concatenate the payloads of the
datagrams for a given response in sequence number order; the resulting byte
stream will contain a complete response in the same format as the TCP
protocol (including terminating \r\n sequences).
